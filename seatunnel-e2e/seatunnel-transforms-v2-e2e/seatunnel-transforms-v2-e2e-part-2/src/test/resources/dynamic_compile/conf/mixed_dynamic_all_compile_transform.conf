#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
######
###### Mixed Three Languages (Java + Groovy + Scala) Dynamic Compilation Test
######

env {
  job.mode = "BATCH"
}

source {
  FakeSource {
    plugin_output = "source_data"
    row.num = 100
    schema = {
      fields {
        id = "int"
        name = "string"
        value = "double"
      }
    }
  }
}

transform {
  DynamicCompile {
    plugin_input = "source_data"
    plugin_output = "java_processed"
    compile_language = "JAVA"
    compile_pattern = "SOURCE_CODE"
    source_code = """
                 import org.apache.seatunnel.api.table.catalog.Column;
                 import org.apache.seatunnel.api.table.type.SeaTunnelRowAccessor;
                 import org.apache.seatunnel.api.table.catalog.*;
                 import org.apache.seatunnel.api.table.type.*;
                 import java.util.ArrayList;

                 public Column[] getInlineOutputColumns(CatalogTable inputCatalogTable) {
                   // Create array directly instead of using ArrayList
                   Column[] columns = new Column[4];

                   // Add original columns
                   columns[0] = PhysicalColumn.of("id", BasicType.INT_TYPE, 10L, true, "", "");
                   columns[1] = PhysicalColumn.of("name", BasicType.STRING_TYPE, 50L, true, "", "");
                   columns[2] = PhysicalColumn.of("value", BasicType.DOUBLE_TYPE, 10L, true, "", "");

                   // Add Java processed column
                   columns[3] = PhysicalColumn.of("java_processed", BasicType.STRING_TYPE, 50L, true, "", "Java processing result");

                   return columns;
                 }

                 public Object[] getInlineOutputFieldValues(SeaTunnelRowAccessor inputRow) {
                   Object[] fieldValues = new Object[4];
                   
                   // Pass through original values
                   fieldValues[0] = inputRow.getField(0);
                   fieldValues[1] = inputRow.getField(1);
                   fieldValues[2] = inputRow.getField(2);
                   
                   // Java processing
                   String javaResult = "JAVA_STEP";
                   fieldValues[3] = javaResult;
                   
                   return fieldValues;
                 }
                """
  }

  # Second transformation: Groovy
  DynamicCompile {
    plugin_input = "java_processed"
    plugin_output = "groovy_processed"
    compile_language = "GROOVY"
    compile_pattern = "SOURCE_CODE"
    source_code = """
                 import org.apache.seatunnel.api.table.catalog.Column
                 import org.apache.seatunnel.api.table.type.SeaTunnelRowAccessor
                 import org.apache.seatunnel.api.table.catalog.*
                 import org.apache.seatunnel.api.table.type.*

                 Column[] getInlineOutputColumns(CatalogTable inputCatalogTable) {
                   Column[] columns = new Column[5]
                   columns[0] = PhysicalColumn.of("id", BasicType.INT_TYPE, 10L, true, "", "")
                   columns[1] = PhysicalColumn.of("name", BasicType.STRING_TYPE, 50L, true, "", "")
                   columns[2] = PhysicalColumn.of("value", BasicType.DOUBLE_TYPE, 10L, true, "", "")
                   columns[3] = PhysicalColumn.of("java_processed", BasicType.STRING_TYPE, 50L, true, "", "")
                   columns[4] = PhysicalColumn.of("groovy_processed", BasicType.STRING_TYPE, 50L, true, "", "Groovy processing result")

                   return columns
                 }

                 Object[] getInlineOutputFieldValues(SeaTunnelRowAccessor inputRow) {
                   def fieldValues = new Object[5]
                   
                   // Pass through all previous values
                   fieldValues[0] = inputRow.getField(0)
                   fieldValues[1] = inputRow.getField(1)
                   fieldValues[2] = inputRow.getField(2)
                   fieldValues[3] = inputRow.getField(3)
                   def groovyResult = "GROOVY_STEP"
                   fieldValues[4] = groovyResult
                   
                   return fieldValues
                 }
                """
  }

  # Third transformation: Scala
  DynamicCompile {
    plugin_input = "groovy_processed"
    plugin_output = "scala_processed"
    compile_language = "SCALA"
    compile_pattern = "SOURCE_CODE"
    source_code = """
                 import org.apache.seatunnel.api.table.catalog.Column
                 import org.apache.seatunnel.api.table.catalog.CatalogTable
                 import org.apache.seatunnel.api.table.catalog.PhysicalColumn
                 import org.apache.seatunnel.api.table.`type`.SeaTunnelRowAccessor
                 import org.apache.seatunnel.api.table.`type`.BasicType
                 import java.util.ArrayList

                 class ScalaFinalProcessor {
                   
                   def getInlineOutputColumns(inputCatalogTable: CatalogTable): Array[Column] = {
                     val columns = new ArrayList[Column]()

                     columns.add(PhysicalColumn.of("id", BasicType.INT_TYPE, 10L, true, "", ""))
                     columns.add(PhysicalColumn.of("name", BasicType.STRING_TYPE, 50L, true, "", ""))
                     columns.add(PhysicalColumn.of("value", BasicType.DOUBLE_TYPE, 10L, true, "", ""))
                     columns.add(PhysicalColumn.of("java_processed", BasicType.STRING_TYPE, 50L, true, "", ""))
                     columns.add(PhysicalColumn.of("groovy_processed", BasicType.STRING_TYPE, 50L, true, "", ""))
                     
                     // Add Scala processed column
                     columns.add(PhysicalColumn.of("scala_processed", BasicType.STRING_TYPE, 100L, true, "", "Scala functional processing result"))
                     columns.toArray(new Array[Column](0))
                   }

                   def getInlineOutputFieldValues(inputRow: SeaTunnelRowAccessor): Array[Object] = {
                     val id = Option(inputRow.getField(0)).map(_.toString.toInt).getOrElse(0)
                     val name = Option(inputRow.getField(1)).map(_.toString).getOrElse("")
                     val value = Option(inputRow.getField(2)).map(_.toString.toDouble).getOrElse(0.0)
                     val javaProcessed = Option(inputRow.getField(3)).map(_.toString).getOrElse("")
                     val groovyProcessed = Option(inputRow.getField(4)).map(_.toString).getOrElse("")
                     Array[Object](
                       id.asInstanceOf[Object],
                       name,
                       value.asInstanceOf[Object],
                       javaProcessed,
                       groovyProcessed,
                       "SCALA_STEP"
                     )
                   }
                 }
                """
  }
}

sink {
  Assert {
    plugin_input = "scala_processed"
    rules = {
      row_rules = [
        {
          rule_type = MIN_ROW
          rule_value = 100
        }
      ],
      field_rules = [
        {
          field_name = id
          field_type = int
          field_value = [
            {
              rule_type = NOT_NULL
            }
          ]
        },
        {
          field_name = name
          field_type = string
          field_value = [
            {
              rule_type = NOT_NULL
            }
          ]
        },
        {
          field_name = value
          field_type = double
          field_value = [
            {
              rule_type = NOT_NULL
            }
          ]
        },
        {
          field_name = java_processed
          field_type = string
          field_value = [
            {
              rule_type = NOT_NULL
              equals_to = "JAVA_STEP"
            }
          ]
        },
        {
          field_name = groovy_processed
          field_type = string
          field_value = [
            {
              rule_type = NOT_NULL
              equals_to = "GROOVY_STEP"
            }
          ]
        },
        {
          field_name = scala_processed
          field_type = string
          field_value = [
            {
              rule_type = NOT_NULL
              equals_to = "SCALA_STEP"
            }
          ]
        }
      ]
    }
  }
}
